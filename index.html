<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vicioware</title>
    <style>
        @font-face {
            font-family: 'Manrope'; /* Nombre que le damos a la fuente para usarla luego */
            src: url('fonts/Manrope-SemiBold.ttf') format('truetype'); /* Ruta al archivo de la fuente y su formato. Asegúrate que el archivo existe. */
            font-weight: 400; /* 'Regular' suele corresponder a un peso de 400. Si es 'Light', usa 300 y el archivo correcto. */
            font-style: normal;
        }

        @keyframes lavaLampEffect {
            0% { background-position: 0% 0%; }     /* Inicia en la esquina superior izquierda del gradiente */
            100% { background-position: 100% 100%; } /* Se mueve hacia la esquina inferior derecha del gradiente */
        }

        body {
            font-family: 'Manrope', sans-serif; /* Usamos Manrope, con sans-serif como fallback */
            margin: 0;
            background-color: #1c1c1c; /* Nuevo color de fondo */
            color: #f0f0f0; /* Color de texto general claro para contraste */
        }
        header {
            background-color: #333;
            color: #fff;
            padding: 1em 0;
            text-align: center;
        }
        .gallery-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start; /* Alinea los items a la izquierda */
            padding: 10px; /* Margen leve alrededor del contenedor */
            gap: 10px; /* Espacio leve entre los elementos */
        }
        .game-item {
            position: relative; /* Necesario para el posicionamiento absoluto del pseudo-elemento ::after */
            background: linear-gradient(to bottom, #1a1a1a, #111111 40%, #0a0a0a); /* Estilo metálico mate oscuro */
            border-radius: 8px;
            text-align: center;
            width: 120px; /* Ancho reducido en un 40% */
            overflow: visible; /* Permitir que el resplandor del pseudo-elemento se muestre fuera */
            text-decoration: none; /* Quita el subrayado del enlace */
            transition: transform 0.2s ease-in-out; /* Mantenemos la transición de hover */
            z-index: 1; /* Asegurar que la tarjeta esté por encima de otros elementos si es necesario */
        }
        .game-item::before, .game-item::after { /* Estilos comunes para ambos pseudo-elementos de resplandor */
            content: '';
            position: absolute;
            opacity: 0;
        }
        .game-item::after { /* Pseudo-elemento para el efecto de resplandor de colores (lava lamp) */
            z-index: -2; /* Detrás del resplandor blanco y del contenido de .game-item */
            inset: -6px; /* Ligeramente más grande que la tarjeta para el efecto glow */
            background: linear-gradient(
                -45deg,
                var(--glow-color-1, #E53935), /* Color 1 - Rojo por defecto */
                var(--glow-color-2, #FFA500), /* Color 2 - Naranja por defecto */
                var(--glow-color-3, #28A745), /* Color 3 - Verde por defecto */
                var(--glow-color-4, #1E90FF), /* Color 4 - Azul por defecto */
                var(--glow-color-5, #7E57C2), /* Color 5 - Violeta por defecto */
                /* Repetimos el primer color para un bucle suave con la animación */
                var(--glow-color-1, #E53935)
            );
            background-size: 300% 300%; /* Aumentado para un mejor barrido de colores */
            animation: lavaLampEffect 15s linear infinite;
            filter: blur(12px); /* Desenfoque para el efecto de resplandor */
            border-radius: 14px; /* (radio original de la tarjeta + valor de inset) */
            transition: opacity 0.4s ease-in-out;
        }
        .game-item::before { /* Pseudo-elemento para el resplandor blanco de contorno */
            z-index: -1; /* Encima del resplandor de colores, detrás del contenido de .game-item */
            inset: 0; /* Coincide con el tamaño de la tarjeta */
            border-radius: 8px; /* Mismo borde que la tarjeta */
            /* Sombra blanca para el contorno, menos intensa que el resplandor de colores */
            box-shadow: 0 0 7px 2px rgba(255, 255, 255, 0.35); 
            transition: opacity 0.3s ease-in-out;
        }
        .game-item:hover {
            transform: scale(1.05); /* Efecto de zoom al pasar el ratón */
        }
        .game-item:hover::after {
            opacity: 0.7; /* Mostrar el resplandor en hover, ajusta la opacidad según prefieras */
        }
        .game-item:hover::before {
            opacity: 1; /* Mostrar el resplandor blanco. La intensidad se controla con la opacidad de la box-shadow */
        }
        .game-item img {
            width: 100%; /* La imagen ocupa todo el ancho del contenedor */
            height: auto; /* Mantiene la proporción de la imagen */
            display: block; /* Ayuda a evitar espacios extra y asegura que el border-radius se aplique bien */
            border-top-left-radius: 8px; /* Redondear esquinas superiores de la imagen */
            border-top-right-radius: 8px; /* Redondear esquinas superiores de la imagen */
        }
        .game-item p {
            margin: 10px 0; /* Margen para el nombre del juego */
            font-size: 0.9em;
            color: #fff; /* Texto blanco */
            text-shadow: 0 0 4px rgba(255, 255, 255, 0.4); /* Resplandor suave para legibilidad */
            padding: 0 5px; /* Espacio para que el texto no toque los bordes */
        }
    </style>
</head>
<body>

    <div class="gallery-container">
        <a href="#" class="game-item">
            <img src="portadas/halo-ce.png" loading="lazy">
            <p>Halo: Combat Evolved</p>
        </a>

        <a href="#" class="game-item">
            <img src="portadas/gta-sa.png" loading="lazy">
            <p>Grand Theft Auto: San Andreas</p>
        </a>

        <a href="#" class="game-item">
            <img src="portadas/cuphead.png" loading="lazy">
            <p>Cuphead</p>
        </a>

        <a href="#" class="game-item">
            <img src="portadas/unmetal.png" loading="lazy">
            <p>Unmetal</p>
        </a>

        <a href="#" class="game-item">
            <img src="portadas/portal.png" loading="lazy">
            <p>Portal</p>
        </a>

        <a href="#" class="game-item">
            <img src="portadas/portal2.png" loading="lazy">
            <p>Portal 2</p>
        </a>

        <a href="#" class="game-item">
            <img src="portadas/REPO.png" loading="lazy">
            <p>R.E.P.O</p>
        </a>

        <a href="#" class="game-item">
            <img src="portadas/dbfz.png" loading="lazy">
            <p>Dragon Ball FighterZ</p>
        </a>

        <a href="#" class="game-item">
            <img src="portadas/brotato.png" loading="lazy">
            <p>Brotato</p>
        </a>

        <a href="#" class="game-item">
            <img src="portadas/assassinscreed.png" loading="lazy">
            <p>Assassin's Creed</p>
        </a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.4.0/color-thief.umd.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gameItems = document.querySelectorAll('.game-item');
            const colorThief = new ColorThief();

            gameItems.forEach(item => {
                const img = item.querySelector('img');
                let dynamicGlowColors = null; // Para almacenar los colores extraídos para este item

                function extractAndStoreColors() {
                    // Asegurarse de que la imagen esté completamente cargada y tenga dimensiones
                    if (img.complete && img.naturalWidth > 0 && img.naturalHeight > 0) {
                        try {
                            const palette = colorThief.getPalette(img, 5); // Extraer 5 colores
                            
                            if (palette && palette.length > 0) {
                                dynamicGlowColors = {};
                                // Asignar colores, usando el primero como fallback si no hay suficientes
                                dynamicGlowColors['--glow-color-1'] = `rgb(${palette[0][0]}, ${palette[0][1]}, ${palette[0][2]})`;
                                dynamicGlowColors['--glow-color-2'] = palette[1] ? `rgb(${palette[1][0]}, ${palette[1][1]}, ${palette[1][2]})` : dynamicGlowColors['--glow-color-1'];
                                dynamicGlowColors['--glow-color-3'] = palette[2] ? `rgb(${palette[2][0]}, ${palette[2][1]}, ${palette[2][2]})` : dynamicGlowColors['--glow-color-1'];
                                dynamicGlowColors['--glow-color-4'] = palette[3] ? `rgb(${palette[3][0]}, ${palette[3][1]}, ${palette[3][2]})` : dynamicGlowColors['--glow-color-1'];
                                dynamicGlowColors['--glow-color-5'] = palette[4] ? `rgb(${palette[4][0]}, ${palette[4][1]}, ${palette[4][2]})` : dynamicGlowColors['--glow-color-1'];
                            } else {
                                console.warn('ColorThief: No se pudo extraer una paleta para:', img.src);
                                dynamicGlowColors = null;
                            }
                        } catch (error) {
                            console.error('ColorThief error para la imagen:', img.src, error);
                            dynamicGlowColors = null;
                        }
                    } else if (!img.complete) {
                        // Si la imagen aún no está completa, no hacer nada aquí, el 'load' listener se encargará.
                    } else {
                        // La imagen está 'complete' pero no tiene dimensiones (ej. imagen rota)
                        console.warn('ColorThief: Imagen cargada pero inválida (sin dimensiones):', img.src);
                        dynamicGlowColors = null;
                    }
                }

                // Intentar extraer colores si la imagen ya está cargada
                // (importante para imágenes cacheadas o ya visibles)
                if (img.complete && img.naturalWidth > 0) {
                    extractAndStoreColors();
                }
                // Siempre añadir el listener 'load' para imágenes que cargan después (incluyendo lazy-loaded)
                img.addEventListener('load', extractAndStoreColors);
                img.addEventListener('error', () => {
                    console.error('Error al cargar la imagen:', img.src);
                    dynamicGlowColors = null;
                });

                item.addEventListener('mouseenter', () => {
                    if (dynamicGlowColors) {
                        for (const [variable, color] of Object.entries(dynamicGlowColors)) {
                            item.style.setProperty(variable, color);
                        }
                    }
                });

                item.addEventListener('mouseleave', () => {
                    // La transición de opacidad para .game-item::after es de 0.4s (400ms).
                    // Retrasamos la eliminación de las variables de color para que coincida
                    // con la duración de la transición, evitando el parpadeo de los colores por defecto.
                    setTimeout(() => {
                        // Solo eliminar las propiedades si el cursor no ha vuelto a entrar en la tarjeta
                        // y si se habían establecido colores dinámicos.
                        if (dynamicGlowColors && !item.matches(':hover')) {
                            item.style.removeProperty('--glow-color-1');
                            item.style.removeProperty('--glow-color-2');
                            item.style.removeProperty('--glow-color-3');
                            item.style.removeProperty('--glow-color-4');
                            item.style.removeProperty('--glow-color-5');
                        }
                    }, 400); // Coincide con la duración de la transición de opacidad de ::after
                });
            });
        });
    </script>
</body>
</html>
